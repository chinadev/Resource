.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pods::man3::noderange.3 3"
.TH pods::man3::noderange.3 3 "2013-02-06" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "Name"
.IX Header "Name"
\&\fBnoderange\fR \- syntax for compactly expressing a list of node names
.SH "\fBSynopsis\fP"
.IX Header "Synopsis"
\&\fIExamples:\fR
.PP
.Vb 1
\& node1,node2,node8,node20,group1
.Ve
.PP
.Vb 1
\& node14-node56,node70-node203,group1-group10
.Ve
.PP
.Vb 1
\& node1,node2,node8,node20,node14-node56,node70-node203
.Ve
.PP
.Vb 1
\& node[14-56]
.Ve
.PP
.Vb 1
\& f[1-3]n[1-20]
.Ve
.PP
.Vb 1
\& all,-node129-node256,-frame01-frame03
.Ve
.PP
.Vb 1
\& /node.*
.Ve
.PP
.Vb 1
\& ^/tmp/nodes
.Ve
.PP
.Vb 1
\& node10+5
.Ve
.PP
.Vb 1
\& 10-15,-13
.Ve
.PP
.Vb 1
\& group1@group2
.Ve
.PP
.Vb 1
\& table.attribute<operator>value
.Ve
.SH "\fBDescription\fP"
.IX Header "Description"
\&\fBnoderange\fR is a syntax that can be used in most xCAT commands to
conveniently specify a list of nodes.  The result is that the  command  will
be applied to a range of nodes, often in parallel.
.PP
\&\fBnoderange\fR is a comma-separated list.  Each token (text between commas)
in the list can be any of the forms listed below:
.PP
Individual node or group:
.PP
.Vb 2
\& node01
\& group1
.Ve
.PP
A range of nodes or groups:
.PP
.Vb 7
\& node01-node10  (equivalent to: node01,node02,node03,...node10)
\& node[01-10]    (same as above)
\& node01:node10  (same as above)
\& node[01:10]    (same as above)
\& f[1-2]n[1-3]   (equivalent to: f1n1,f1n2,f1n3,f2n1,f2n2,f2n3)
\& group1-group3  (equivalent to: group1,group2,group3)
\& (all the permutations supported above for nodes are also supported for groups)
.Ve
.PP
\&\fBnodeRange\fR tries to be intelligent about detecting padding, so
you can specify \*(L"node001\-node200\*(R" and it will add the proper number of
zeroes to make all numbers 3 digits.
.PP
An incremented range of nodes:
.PP
.Vb 1
\& node10+3  (equivalent to: node10,node11,node12,node13)
.Ve
.PP
A node shorthand range of nodes:
.PP
.Vb 2
\& 10-20   (equivalent to: node10,node11,node12,...node20)
\& 10+3    (equivalent to: node10,node11,node12,node13)
.Ve
.PP
Currently, the prefix that will be prepended for the above syntax is always \*(L"node\*(R".
Eventually, the prefix and optional suffix will be settable via the environment variables
\&\s-1XCAT_NODE_PREFIX\s0 and \s-1XCAT_NODE_SUFFIX\s0, but currently this only works in bypass mode.
.PP
A regular expression match of nodes or groups:
.PP
.Vb 2
\& /node[345].*   (will match any nodes that start with node3, node4, or node5)
\& /group[12].*   (will match any groups that start with group1 or group2)
.Ve
.PP
The path of a file containing noderanges of nodes or groups:
.PP
.Vb 1
\& ^/tmp/nodelist
.Ve
.PP
where /tmp/nodelist can contain entries like:
.PP
.Vb 8
\& #my node list (this line ignored)
\& ^/tmp/foo #ignored
\& node01    #node comment
\& node02
\& node03
\& node10-node20
\& /group[456].*
\& -node50
.Ve
.PP
Node ranges can contain any combination:
.PP
.Vb 1
\& node01-node30,node40,^/tmp/nodes,/node[13].*,2-10,node50+5
.Ve
.PP
Any individual \fBnoderange\fR may be prefixed with an exclusion operator
(default \-) with the exception of the file operator (default ^).  This will cause
that individual noderange to be subtracted from the total resulting list of nodes.
.PP
The intersection operator @ calculates the intersection of the left and
right sides:
.PP
.Vb 1
\& group1@group2   (will result in the list of nodes that group1 and group2 have in common)
.Ve
.PP
Any  combination  or  multiple  combinations of inclusive and exclusive
ranges of nodes and groups is legal.  There is no precedence implied in
the  order  of  the  arguments.   Exclusive ranges have precedence over
inclusive.  Parentheses can be used to explicitly specify precendence of any operators.
.PP
Nodes have precedence over groups.  If a node range match is made then
no group range match will be attempted.
.PP
All node and group names are validated against the nodelist table.  Invalid names
are ignored and return nothing.
.Sh "\fBxCAT Node Name Format\fP"
.IX Subsection "xCAT Node Name Format"
Throughout this man page the term \fBxCAT Node Name Format\fR is used.
\&\fBxCAT Node Name Format\fR is defined by the following regex:
.PP
.Vb 1
\& ^([A-Za-z-]+)([0-9]+)(([A-Za-z-]+[A-Za-z0-9-]*)*)
.Ve
.PP
In  plain  English,  a  node or group name is in \fBxCAT Node Name Format\fR if starting
from the begining there are:
.IP "\(bu" 2
one or more alpha characters  of  any  case and  any  number  of \*(L"\-\*(R" in any combination
.IP "\(bu" 2
followed by one or more numbers
.IP "\(bu" 2
then optionally followed by one alpha character of any case  or \*(L"\-\*(R"
.IP "\(bu" 2
followed by any combination of case mixed alphanumerics and \*(L"\-\*(R"
.PP
\&\fBnoderange\fR supports node/group names in \fIany\fR format.  \fBxCAT Node Name Format\fR is
\&\fBnot\fR required, however some node range methods used to determine range
will not be used for non-conformant names.
.PP
Example of \fBxCAT Node Name Format\fR node/group names:
.PP
.Vb 10
\& NODENAME           PREFIX      NUMBER   SUFFIX
\& node1              node        1
\& node001            node        001
\& node-001           node-       001
\& node-foo-001-bar   node-foo-   001      -bar
\& node-foo-1bar      node-foo-   1        bar
\& foo1bar2           foo         1        bar2
\& rack01unit34       rack        01       unit34
\& unit34rack01       unit        34       rack01
\& pos0134            pos         0134
.Ve
.SH "\fBExamples\fP"
.IX Header "Examples"
.IP "1." 3
Generates a list of all nodes (assuming all is a group) listed in the
\&\fBnodelist\fR table less node5 through node10:
.Sp
.Vb 1
\& all,-node5-node10
.Ve
.IP "2." 3
Generates  a  list  of  nodes 1 through 10 less nodes 3,4,5.  Note that
node4 is listed twice, first in the range and then at the end.  Because
exclusion has precedence node4 will be excluded.
.Sp
.Vb 1
\& node1-node10,-node3-node5,node4
.Ve
.IP "3." 3
Generates a list of nodes 1 through 10 less nodes 3 and 5.
.Sp
.Vb 1
\& node1-node10,-node3,-node5
.Ve
.IP "4." 3
Generates  a  list  of  all  (assuming  `all'  is a group) nodes in the
\&\fBnodelist\fR table less 17 through 32.
.Sp
.Vb 1
\& -node17-node32,all
.Ve
.IP "5." 3
Generates a list of nodes 1 through 128, and user nodes 1 through 4.
.Sp
.Vb 1
\& node1-node128,user1-user4
.Ve
.IP "6." 3
Generates a list of all nodes (assuming `all' is a group),  less  nodes
in  groups rack1 through rack3 (assuming groups rack1, rack2, and rack3
are defined), less nodes 100 through 200, less  nodes  in  the  storage
group.  Note that node150 is listed but is excluded.
.Sp
.Vb 1
\& all,-rack1-rack3,-node100-node200,node150,-storage
.Ve
.IP "7." 3
Generates  a  list of nodes matching the regex \fInode[23].*\fR.  That is all
nodes that start with node2 or node3 and end in  anything  or  nothing.
E.g. node2, node3, node20, node30, node21234 all match.
.Sp
.Vb 1
\& /node[23].*
.Ve
.IP "8." 3
Generates  a  list of nodes which have the value hmc in the nodehm.cons 
attribute. 
.Sp
.Vb 1
\& nodehm.cons==hmc
.Ve
.Sp
.Vb 1
\& nodehm.cons=~hmc
.Ve
.IP "9." 3
Generate a list of nodes in the 1st two frames:
.Sp
.Vb 1
\& f[1-2]n[1-42]
.Ve
.SH "\fBSEE ALSO\fP"
.IX Header "SEE ALSO"
\&\fInodels\fR\|(1)
